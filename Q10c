import random
import math

print ("enter the dimensions\n")
dim = int(input ())



flag=[]#flag values of all the cells
flag1=[]
flag2=[]
flag3=[]
final_flag=[]
nodes_expanded = 0
path_flag = ""
#path_flag=''#a flag to know that the path is found and break out of the loop
A = []#stack A
final_path=[]#the final path traversed

first_quarter = dim**2/4
three_quarter = 3*(dim**2)/4

# ---------Function starts------------ #

def MazeGen(a,b,p):#Generates a random maze
    flag=[]
    index=random.sample(range(int(a),int(b-2)), int(p*(b-a)))
    for i in range(int(a-1),int(b)):
        if i in index:
            flag.append(1)
        else:
            flag.append(0)
    return flag
    
# ---------Function stops------------ #

# ---------Function starts------------ #

def CreateMaze(low_prob,high_prob):
    flag1 = MazeGen(1,first_quarter,low_prob)

    flag2 = MazeGen(first_quarter,three_quarter,high_prob)

    flag3 = MazeGen(three_quarter,(dim**2)-1,low_prob)

    final_flag = flag1 + flag2 + flag3
    return final_flag 

# ---------Function stops------------ #

  
maze=[]
index=[]
FringeList=[]
path=[]
td=[]

def iniFL(k):
    if len(FringeList)>0:
        while len(FringeList)>0:
            FringeList.pop(0)
    for j in range(k**2):
        FringeList.append([0]) 
        
def initd(k):
    for j in range(k**2):
        td.append(0)



def parent(node):
    "Returns parent node"
    for a in FringeList:
        if node in a:
            return FringeList.index(a)

def pathGen(c):
    "displays a path"
    if c==0:
        return
    while(c!=0):
        global final_path
        final_path.append(c)
        c=parent(c)

def Make_Fringe_AS(MAZE,Qu,d):
    "Generates a fringe for a given cell"
    top=len(Qu)-1
    fringe=[]
    if (Qu[top]-d)>0:
        if MAZE[Qu[top]-d]==0 and Qu[top]-d not in Qu:
            fringe.append(Qu[top]-d)
            td[Qu[top]-d]=td[Qu[top]]+1
    if (Qu[top]+d)<d**2:
        if MAZE[Qu[top]+d]==0 and Qu[top]+d not in Qu:
            fringe.append(Qu[top]+d)
            td[Qu[top]+d]=td[Qu[top]]+1
    if Qu[top]%d!=0:
        if MAZE[Qu[top]-1]==0 and Qu[top]-1 not in Qu:
            fringe.append(Qu[top]-1)
            td[Qu[top]-1]=td[Qu[top]]+1
    if Qu[top]%d!=-1:
        if MAZE[Qu[top]+1]==0 and Qu[top]+1 not in Qu:
            fringe.append(Qu[top]+1)
            td[Qu[top]+1]=td[Qu[top]]+1
    #print(fringe)
    FringeList[Qu[top]]=fringe
    return fringe   

def h(n,dim):
    z=0
    x = int(n/dim)+1
    y = (n%dim)+1
    z=(dim-x)**2 + (dim-y)**2
    return math.sqrt(z)

def perm(F,dim): 
    score=0
    a=[]
    b=[]
    c=[]
    for i in F:
        score=td[i]+h(i,dim)
        a.append([i,score])
    for i in a:
        b.append(i[1])
    b.sort()
    b.reverse()
    for j in b:
        for k in a:
            if j in k and k[0] not in c:
                c.append(k[0])
                break
    return c
        
def A_star(MAZE,dim):
    AQ=[0]
    global nodes_expanded
    nodes_expanded = 0
    while True:
        TOP=len(AQ)-1
        if (dim**2)-1 in AQ:
            global path_flag
            path_flag = "path found"
            break
        elif len(AQ)==0:
            path_flag = "path not found"
            break
        else:
            temp=AQ[TOP]
            nodes_expanded +=1
            AQ = AQ + perm(Make_Fringe_AS(MAZE,AQ,dim),dim)
            MAZE[temp]=1
            AQ.remove(temp)
            #print(AQ)
            #print(temp)
    return temp   
       
    

top_prob = 0.3
middle_prob = 0.3

    
 
difficulty_counter = 0
while (difficulty_counter!=1000 ) and (middle_prob<=1) and (top_prob<=1):

    final_flag = CreateMaze(top_prob,middle_prob)
    
    iniFL(dim)
    initd(dim)

    ltn=A_star(final_flag,dim)
    
    if path_flag=="path found":
        middle_prob = middle_prob + 0.05
        top_prob = top_prob + 0.05
        difficulty_counter = 0
    elif path_flag=="path not found":
        difficulty_counter+=1

        
print ("difficult path found")

final_flag = CreateMaze(top_prob,middle_prob)

k=0
for i in range(dim**2):
    if (k==dim):
        print ("\n")
        k=0
    print (final_flag[i], end=' ')
    k+=1
print ("\n")


        
        
usable_middle_prob = middle_prob - 0.01
usable_top_prob = top_prob - 0.01
print (usable_middle_prob,usable_top_prob)


while (path_flag!="path found"):
    
    final_flag = CreateMaze(usable_top_prob,usable_middle_prob)

    iniFL(dim)
    initd(dim)
    ltn=A_star(final_flag,dim)

    

pathGen(ltn)
print (len(final_path)+1)
print (nodes_expanded)



    






            
            
    

