import random
import math

print ("enter the dimensions\n")
dim = int(input ())

index=[]
FringeList=[]
path=[]
td=[]
path_flag=""
scoreList=[]
count=0
nodes_expanded=0
first_quarter = dim**2/4
three_quarter = 3*(dim**2)/4
final_path_length=0



def iniFL(k):
    if len(FringeList)>0:
        while len(FringeList)>0:
            FringeList.pop(0)
    for j in range(k**2):
        FringeList.append([]) 
        
def initd(k):
    for j in range(k**2):
        td.append(0)

def inisl(k):
    for j in range(k**2):
        scoreList.append(0)

def MazeGen(a,b, p):
    "Generates a random maze"
    maze=[]
    iniFL(dim)
    initd(dim)
    inisl(dim)
    index=random.sample(range(int(a),int(b-2)), int(p*(b-a)))
    #print(index)
    for i in range(int(a-1),int(b)):
        if i in index:
            maze.append(1)
        else:
            maze.append(0)
    return maze

# ---------Function starts------------ #

def CreateMaze(low_prob,high_prob):
    flag1 = MazeGen(1,first_quarter,low_prob)

    flag2 = MazeGen(first_quarter,three_quarter,high_prob)

    flag3 = MazeGen(three_quarter,(dim**2)-1,low_prob)

    final_flag = flag1 + flag2 + flag3
    return final_flag 

# ---------Function stops------------ #


def parent(node):
    "Returns parent node"
    if node==0:
        return 0
    for a in FringeList:
        if node in a:
            return FringeList.index(a)

def pathGen(c):
    "displays a path"
    pl=0
    while c!=0:
        #print(c)
        pl+=1
        c=parent(c)
    return pl   
 

def h_ed(n,dim):
    z=0
    x = int(n/dim)+1
    y = (n%dim)+1
    z = ((dim-x)**2) + ((dim-y)**2)
    return math.sqrt(z)


def perm(F,dim): 
    score=0
    a=[]
    b=[]
    c=[]
    for i in F:
        if scoreList[i]!=0:
            a.append([i,score])
        else:
            score=td[i]+h_ed(i,dim)
            scoreList[i]=score
            a.append([i,score])
    for i in a:
        b.append(i[1])
    b.sort()
    for j in b:
        for k in a:
            if j in k and k[0] not in c:
                c.append(k[0])
                break
    return c

    
def Make_Fringe_AS(MAZE,Qu,d):
    "Generates a fringe for a given cell"
    fringe=[]
    top=len(Qu)-1
    if (Qu[top]+d)<d**2:
        if MAZE[Qu[top]+d]==0 and Qu[top]+d not in Qu:
            fringe.append(Qu[top]+d)
            td[Qu[top]+d]=td[Qu[top]]+1
    if (Qu[top]+1)%d!=0:
        if MAZE[Qu[top]+1]==0 and Qu[top]+1 not in Qu:
            fringe.append(Qu[top]+1)
            td[Qu[top]+1]=td[Qu[top]]+1 
    if (Qu[top]-d)>0:
        if MAZE[Qu[top]-d]==0 and Qu[top]-d not in Qu:
            fringe.append(Qu[top]-d)
            td[Qu[top]-d]=td[Qu[top]]+1
    if Qu[top]%d!=0:
        if MAZE[Qu[top]-1]==0 and Qu[top]-1 not in Qu:
            fringe.append(Qu[top]-1)
            td[Qu[top]-1]=td[Qu[top]]+1 
    #print(fringe)
    FringeList[Qu[top]]=fringe
    return fringe
    
        
def A_star(MAZE,dim):
    AQ=[0]
    global nodes_expanded
    nodes_expanded=0
    while True:
        if (dim**2)-1 in AQ:
            global path_flag
            path_flag="path found"
            break
        elif len(AQ)==0:
            path_flag="path not found"
            break
        else:
            nodes_expanded=nodes_expanded+1
            temp=AQ[len(AQ)-1]
            AQ = AQ + Make_Fringe_AS(MAZE,AQ,dim)
            MAZE[temp]=1
            AQ.remove(temp)
            AQ=perm(AQ,dim)
            #print(AQ)
    return(temp)
 


 

  
top_prob = 0.4
middle_prob = 0.2

difficulty_counter=0   
while (difficulty_counter!=100) and (middle_prob<=1) and (top_prob<=1):
    final_maze = CreateMaze(top_prob,middle_prob)

    ltn=A_star(final_maze,dim)
   
    if path_flag=="path found":
        top_prob = top_prob + 0.005
        middle_prob = middle_prob + 0.01
        difficulty_counter = 0
        difficulty_counter=difficulty_counter+1
    elif path_flag=="path not found":
        difficulty_counter+=1


print ("difficult path found")

final_maze = CreateMaze(top_prob,middle_prob)

k=0
for i in range(dim**2):
    if (k==dim):
        print ("\n")
        k=0
    print (final_maze[i], end=' ')
    k+=1
print ("\n")

usable_top_prob = top_prob - 0.005
usable_middle_prob = middle_prob - 0.01

print (usable_top_prob,usable_middle_prob)

while (path_flag!="path found"):
    
    final_maze = CreateMaze(usable_top_prob,usable_middle_prob)
    ltn=A_star(final_maze,dim)

max_fringe_size = 0
for i in FringeList:
    max_fringe_size = max_fringe_size + len(i)
    
final_path_length = pathGen(ltn)+1
print (final_path_length)
print (nodes_expanded)
print (max_fringe_size)

            
            
    

